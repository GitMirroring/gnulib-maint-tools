# This program determines the features of a Bourne-compatible shell.
# Usage: SHELL sh-features 2>/dev/null
# You find the known results at the end of this script.

echo '1 - printf builtin supports octal escapes correctly'
echo '2 - double-quotes inside backquotes'
echo '3 - accepted by configure (generated by autoconf 2.72)'
echo '4 - $(...) syntax for command substitution'
echo '5 - ${var#...} syntax for removing a prefix'
echo '6 - ${var%...} syntax for removing a suffix'
echo '7 - arithmetic without expr'
echo '8 - assign and export variable in one step'
echo '9 - local variables with non-surprising semantics'
echo '10 - sane tracing (set -x)'
echo '11 - locally bound shell options'
echo '12 - $'"'...'"' syntax for string literals'
echo '13 - read -r option that avoids backslash-processing'
echo '14 - function keyword'
echo '15 - append operator'
echo '16 - associative arrays'

if { LC_ALL=en_US.UTF-8 printf "\\351" 2>/dev/null \
     | LC_ALL=C tr "\\351" x | LC_ALL=C grep "^x$" > /dev/null; } \
   && { printf "\\351" 2>/dev/null \
        | LC_ALL=C tr "\\351" x | LC_ALL=C grep "^x$" > /dev/null; }; then
  printf_works=yes
else
  printf_works=no
fi

if ( echo "`echo \"hello\"`" | grep '^hello$' ) >/dev/null 2>&1; then
  dquote_inside_backquote=yes
else
  dquote_inside_backquote=no
fi

as_bourne_compatible="if test \${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else case e in #(
  e) case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac ;;
esac
fi
"
as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }
exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" )
then :

else case e in #(
  e) exitcode=1; echo positional parameters were not saved. ;;
esac
fi
test x\$exitcode = x0 || exit 1
blah=\$(echo \$(echo blah))
test x\"\$blah\" = xblah || exit 1
test -x / || exit 1"
as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
test \$(( 1 + 1 )) = 2 || exit 1"
if (eval "$as_required") 2>/dev/null
then :
  as_have_required=yes
else case e in #(
  e) as_have_required=no ;;
esac
fi

if (eval 'test $(echo y) = y'); then
  posix_command_subst=yes
else
  posix_command_subst=no
fi

if ( foo=bar; eval 'test "${foo#b}" = ar' ) >/dev/null 2>&1; then
  remove_prefix_works=yes
else
  remove_prefix_works=no
fi

if ( foo=bar; eval 'test "${foo%r}" = ba' ) >/dev/null 2>&1; then
  remove_suffix_works=yes
else
  remove_suffix_works=no
fi

if ( eval 'foo=$((24 + 18)); echo $foo | grep 42' ) >/dev/null 2>&1; then
  arithmetic=yes
else
  arithmetic=no
fi

if ( export foo=bu; echo $foo$foo | grep bubu ) >/dev/null 2>&1; then
  export_assignment=yes
else
  export_assignment=no
fi

f_local_() { local v=1; }
f_dash_local_fail_() { local t=`printf " 1"`; }
if f_local_ && f_dash_local_fail_; then
  local_works=yes
else
  local_works=no
fi

trace_err=`(exec 3>&1; set -x; P=1 true 2>&3) 2> /dev/null`
if test -z "$trace_err"; then
  tracing_works=yes
else
  tracing_works=no
fi

f_tracing_off() { local -; set +x; is_tracing_2=`{ :; } 2>&1`; }
f_tracing_on()  { local -; set -x; is_tracing_5=`{ :; } 2>&1`; }
set -x
is_tracing_1=`{ :; } 2>&1`
f_tracing_off
is_tracing_3=`{ :; } 2>&1`
set +x
is_tracing_4=`{ :; } 2>&1`
f_tracing_on
is_tracing_6=`{ :; } 2>&1`
set +x
if test -n "$is_tracing_1" && test -z "$is_tracing_2" && test -n "$is_tracing_3" \
   && test -z "$is_tracing_4" && test -n "$is_tracing_5" && test -z "$is_tracing_6"; then
  locally_bound_options=yes
else
  echo "is_tracing_1=$is_tracing_1" 1>&2
  echo "is_tracing_2=$is_tracing_2" 1>&2
  echo "is_tracing_3=$is_tracing_3" 1>&2
  echo "is_tracing_4=$is_tracing_4" 1>&2
  echo "is_tracing_5=$is_tracing_5" 1>&2
  echo "is_tracing_6=$is_tracing_6" 1>&2
  locally_bound_options=no
fi

if test $'\r' = `printf '\r'`; then
  dollar_single_quote=yes
else
  dollar_single_quote=no
fi

if ( printf '%s\n' 'foo\tbar' | { read -r word; echo "$word"; } | grep foo..bar ) >/dev/null 2>&1; then
  read_option_r=yes
else
  read_option_r=no
fi

if ( eval 'function fu () { echo 42; }' ) >/dev/null 2>&1; then
  function_keyword=yes
else
  function_keyword=no
fi

if ( foo=bar; foo+=baz && test "$foo" = barbaz ) >/dev/null 2>&1; then
  append_operator=yes
else
  append_operator=no
fi

if (declare -A x && { x[f/2]='foo'; x[f/3]='bar'; eval test '${x[f/2]}' = foo; }) 2>/dev/null; then
  associative_arrays=yes
else
  associative_arrays=no
fi

echo "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16"
echo "$printf_works $dquote_inside_backquote $as_have_required $posix_command_subst $remove_prefix_works $remove_suffix_works $arithmetic $export_assignment $local_works $tracing_works  $locally_bound_options  $dollar_single_quote  $read_option_r  $function_keyword  $append_operator  $associative_arrays" \
  | sed -e 's/yes/Y/g' -e 's/no/-/g'

exit 0

====================== Results ======================
1 - printf builtin supports octal escapes correctly
2 - double-quotes inside backquotes
3 - accepted by configure (generated by autoconf 2.72)
4 - $(...) syntax for command substitution
5 - ${var#...} syntax for removing a prefix
6 - ${var%...} syntax for removing a suffix
7 - arithmetic without expr
8 - assign and export variable in one step
9 - local variables with non-surprising semantics
10 - sane tracing (set -x)
11 - locally bound shell options
12 - $'...' syntax for string literals
13 - read -r option that avoids backslash-processing
14 - function keyword
15 - append operator
16 - associative arrays

                    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
bash 1.14.7         Y Y Y Y Y Y Y Y Y Y  -  -  Y  Y  -  -
bash 2.05b          Y Y Y Y Y Y Y Y Y Y  -  Y  Y  Y  -  -
bash 3.2.57         Y Y Y Y Y Y Y Y Y Y  -  Y  Y  Y  Y  -
bash 4.4.18         Y Y Y Y Y Y Y Y Y Y  Y  Y  Y  Y  Y  Y
bash 5.2.21         Y Y Y Y Y Y Y Y Y Y  Y  Y  Y  Y  Y  Y
dash 0.5.12         Y Y Y Y Y Y Y Y Y Y  Y  -  -  -  -  -
zsh 5.9             Y Y Y Y Y Y Y Y Y Y  Y  Y  -  Y  Y  Y
busybox sh          Y Y Y Y Y Y Y Y Y Y  Y  Y  Y  Y  -  -
macOS 12 sh         Y Y Y Y Y Y Y Y Y Y  -  Y  -  Y  Y  -
FreeBSD 5.2.1 sh    Y Y Y Y Y Y Y Y - Y  Y  -  Y  -  -  -
FreeBSD 14.0 sh     Y Y Y Y Y Y Y Y Y Y  Y  Y  Y  -  -  -
NetBSD 10.0 sh      Y Y Y Y Y Y Y Y - Y  Y  Y  Y  -  -  -
OpenBSD 7.5 sh      Y Y Y Y Y Y Y Y Y -  Y  -  -  -  -  -
AIX 7.1 sh          Y Y Y Y Y Y Y Y Y -  Y  -  -  -  -  -
Solaris 10 sh       Y Y - - - - - - - -  -  -  -  -  -  -
Solaris 11 sh       Y Y Y Y Y Y Y Y - -  -  Y  -  -  Y  -


Details for 8:

bash 1.14.7, bash 2.05b, bash 3.2.57, macOS 10.5 sh, macOS 12 sh
is_tracing_1=++ :
is_tracing_2=
is_tracing_3=
is_tracing_4=
is_tracing_5=++ :
is_tracing_6=++ :

Solaris 10 sh, Solaris 11 sh
is_tracing_1=+ :
is_tracing_2=
is_tracing_3=
is_tracing_4=
is_tracing_5=+ :
is_tracing_6=+ :

